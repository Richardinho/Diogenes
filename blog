
<h3>Why Dependency Injection?</h3>
<p>
 Javascript applications are composed of objects which interact with each other. Objects that an object interacts with are known as 'dependencies'. When an object is created it is necessary for its dependencies to also be created so that it can function correctly. The creation of objects and their dependencies is one of the major challenges of software development.

 To cut a long story short, dependency injection, or DI as I will refer to it henceforth, is in my opinion the best solution to this problem. To show why I will discuss the alternatives.
</p>

<h3>Strategy 1: Objects are responsible for their dependencies</h3>

<p>
    One way to create objects is imperatively, using object literals or the 'new' keyword.
</p>
<pre>
    <code>

    function Foo() {
        this.dep1 = new Dep1();
        this.dep2 = new Dep2();
    }

    let foo = new Foo();

    </code>
</pre>
<p>
    In this strategy, objects are responsible for creating and managing their own dependencies. In the above example when the foo object is instantiated, its dependencies are instantiated in turn within its constructor function. The advantage of this approach is that it is easy and quick to implement. For small applications and prototypes it is probably entirely sufficient.
    The problems with it emerge as the application gets larger. When you are dealing with dozens of objects rather than just a couple, the code base quickly becomes cluttered with a lot of object creation code. This makes the code harder to read and harder to maintain. Because objects are 'hard wired' to their dependencies it also makes it difficult, or impossible, to
    swap in alternative implementations for a dependency such as you might want to do in unit testing. In short, this  strategy does not scale well.
</p>
<h3>Strategy 2: Pass in dependencies from the outside</h3>
<p>
The problem with the previous strategy was that objects were in charge of creating their own dependencies. In other words, the dependencies came from within the objects themselves. A different approach is for an object to obtain its dependencies from outside of themselves: that is to say the dependencies are created separately then passed into an object when it is created.
</p>
<pre><code>

    function Foo(dep1, dep2) {
        this.dep1 = dep1;
        this.dep2 = dep2;
    }

    //  dep1 and dep2 created elsewhere

    new Foo(dep1, dep2);

</code></pre>

<p>
In this example, an object's dependencies are passed into the constructor function. The dependencies themselves will be created in a similar way. The advantage of this approach is that an object has been decoupled from its dependencies. It is now possible to pass different implementations for each dependency. The obvious example would be unit testing where a mock object can be passed in, allowing the object to be tested in isolation.
</p>
<p>
    The problem is that we still have to manually write object creation code. We have simply shifted it off to another place.
    Also the collection of interconnected objects can form a tree several layers deep and objects at the lower levels need their dependencies to be passed in through the upper levels. Thus you can find that constructor functions have large numbers of arguments which they themselves don't use. This can become hard to maintain. Again we have a scalability problem.

</p>
<h3>Strategy 3: DI</h3>
<p>
Now we come to DI and to explain why it solves the problem of object creation better than the previous two approaches.
Where both of these followed an imperative programming paradigm, DI is declarative. By this we mean that an object simply declares what dependencies it has and the DI system 'magically' creates them.  A DI system consists of a way for objects to declare their dependencies and a mechanism for creating objects and their associated dependencies. Since the DI system is normally implemented as a separate library, this means that the application itself is free of all object creation code. DI results in objects being decoupled from each other which makes it possible to substitute different implementations in for a dependency. The mechanism for declaring dependencies should be as unobtrusive as possible so that the DI system is as transparent as possible to the application.
</p>
<p>DI is common in the server world and is a staple of software development frameworks such as Spring for JAVA. It is less common in the front end sphere. As front end applications become more elaborate there is a growing need for it however. This need has been met most prominently by the Angular framework which features an implementation of DI. Angular's DI however is not separable from Angular itself. For non Angular projects there is a lack of alternatives. This is where Diogenes comes  in.</p>
<h3>Diogenes: a DI implementation</h3>
<p>
    Diogenes is a small DI library written by myself. It is hosted on NPM and can be imported as a node module. The source code
    is on Github. A simple example of using it follows.
</p>
<pre><code>

    var injector = new Injector();

	var Foo = function (options) {
		this.dep1 = options.dep1;
		this.dep2 = options.dep2;
	}

	Foo.inject = ['dep1', 'dep2'];

	injector.register('foo', DataService, Injector.INSTANCE );

	//  declarations and registration of dep1 and dep2 not shown

	let foo = injector.get('foo');

</code></pre>
<p>
    In the above example, the constructor function for Foo is similar to that shown in strategy 2 above. Foo is in every sense a 'plain old javascript object'. To make DI work all we have added is a static property called 'inject'. This is an array of strings representing the dependencies which we want to inject into our instance.  At the top of the example we create an injector object. This is in charge of our DI system.The register method is used to register with the injector all those objects which we wish to partake in the DI system.It requires three arguments: a key with which to identify the object; a service provider which in this case is the constructor for Foo, and a third argument which tells the injector what sort of object to create.  The procedure is as follows: The 'get' method on the injector asks the injector to create and return the requested object. The injector reads the 'inject' array on the Foo constructor and sees that it needs the two dependencies 'dep1' and 'dep2'. It will make sure that service providers for these keys have been registered with itself and assuming that they have it will instantiate them. These instances will then be passed to the Foo constructor which will be called to create an instance of itself. The instantiated object will be returned to the user.
</p>
<p>The 'Injector.INSTANCE' argument tells the injector to always return a new instance of Foo. Other arguments are possible: For example 'Injector.CACHE_INSTANCE' tells the injector to create an instance the first time get() is called but to always return this same instance on subsequent calls; 'Injector.VALUE' allows a value to be stored as the service provider; 'Injector.FACTORY' allows a function that returns an object to be the service provider.
</p>
<p>

The injector itself can be registered with itself which allows objects to declare it as a dependency and to get objects directly out of it. This can be useful when an object doesn't know its dependencies until run time.
</p>







